<?php


declare( strict_types = 1 );


namespace JDWX\Trie;


use ArrayAccess;
use InvalidArgumentException;
use RuntimeException;


/**
 * @implements ArrayAccess<string, mixed>
 */
class Trie implements ArrayAccess {



    protected TrieNodeNavigator $tnRoot;


    public function __construct( private readonly bool $bAllowVariables = false ) {
        $this->tnRoot = new TrieNodeNavigator();
    }


    /**
     *
     * @return list<?string>
     *
     * This function will probably need to be overloaded in a subclass
     * to deal with the variable values. For the base implementation,
     * it allows variable values to use alphanumeric characters, plus
     * underscore, period, and hyphen. That's pretty arbitrary.
     */
    public static function extractVariableValue( string $i_stPath ) : array {
    }


    public function add( string $i_stPath, mixed $i_xValue ) : void {
        $this->tnRoot->add( $i_stPath, $i_xValue, $this->bAllowVariables );
    }


    /** @param array<string,string>|null &$o_nrVariables */
    public function get( string $i_stPath, ?array &$o_nrVariables = null ) : mixed {
        if ( is_array( $o_nrVariables ) ) {
            $o_nrVariables = [];
        }
        $node = $this->getInner( $this->tnRoot, $i_stPath, $o_nrVariables, true );
        return $node?->xValue;
    }


    public function has( string $i_stPath, bool $i_bDecodeVariables = false ) : bool {
        $r = null;
        $node = $this->getInner( $this->tnRoot, $i_stPath, $r, $i_bDecodeVariables );
        return $node?->xValue !== null;
    }


    /**
     * @param string $offset
     * @return bool
     * @suppress PhanTypeMismatchDeclaredParamNullable
     */
    public function offsetExists( mixed $offset ) : bool {
        /** @phpstan-ignore-next-line */
        if ( ! is_string( $offset ) ) {
            throw new InvalidArgumentException( 'Trie keys must be strings.' );
        }
        return $this->has( $offset );
    }


    /**
     * @param string $offset
     * @return mixed
     * @suppress PhanTypeMismatchDeclaredParamNullable
     */
    public function offsetGet( mixed $offset ) : mixed {
        /** @phpstan-ignore-next-line */
        if ( ! is_string( $offset ) ) {
            throw new InvalidArgumentException( 'Trie keys must be strings.' );
        }
        return $this->get( $offset );
    }


    /**
     * @param string $offset
     * @param mixed $value
     * @suppress PhanTypeMismatchDeclaredParamNullable
     */
    public function offsetSet( mixed $offset, mixed $value ) : void {
        /** @phpstan-ignore-next-line */
        if ( ! is_string( $offset ) ) {
            throw new InvalidArgumentException( 'Trie keys must be strings.' );
        }
        $this->set( $offset, $value );
    }


    /**
     * @param string $offset
     * @suppress PhanTypeMismatchDeclaredParamNullable
     */
    public function offsetUnset( mixed $offset ) : void {
        /** @phpstan-ignore-next-line */
        if ( ! is_string( $offset ) ) {
            throw new InvalidArgumentException( 'Trie keys must be strings.' );
        }
        $this->unset( $offset );
    }


    /*
    public function set( string $i_stPath, mixed $i_xValue ) : void {
        $this->tnRoot->setDeep( $i_stPath, $i_xValue, $this->bAllowVariables );
    }
    */


    public function unset( string $i_stPath, bool $i_bPrune = false ) : void {
        $r = null;
        $node = $this->getInner( $this->tnRoot, $i_stPath, $r, false );
        if ( $node instanceof TrieNode ) {
            $node->xValue = null;
            if ( $i_bPrune ) {
                $node->rConstants = [];
                $node->rVariables = [];
            }
        }
    }


    /**
     * @param array<string, string>|null &$o_nrVariables An optional array to store variable values.
     * @return TrieNode|null The node that matches the path, or null if not found.
     */
    protected function getInner( TrieNode $i_node, string $i_stPath, ?array &$o_nrVariables,
                                 bool     $i_bDecodeVariables ) : ?TrieNode {
        $stPath = $i_stPath;
        $nodeMatch = $i_node->getClosestConstant( $stPath );
        if ( '' === $stPath ) {
            return $nodeMatch;
        }
        if ( ! $this->bAllowVariables || empty( $nodeMatch->rVariableChildren ) ) {
            return null;
        }

        if ( $i_bDecodeVariables ) {
            [ $stValue, $stPath ] = static::extractVariableValue( $stPath );
        } else {
            [ $stValue, $stPath ] = TrieNode::extractVariableName( $stPath );
        }
        if ( null === $stValue ) {
            return null;
        }

        if ( empty( $stPath ) ) {
            if ( 1 === count( $nodeMatch->rVariableChildren ) ) {
                $stVarName = array_keys( $nodeMatch->rVariableChildren )[ 0 ];
                $o_nrVariables[ $stVarName ] = $stValue;
                return $nodeMatch->rVariableChildren[ $stVarName ];
            }
            $stKeys = join( ', ', array_keys( $nodeMatch->rVariableChildren ) );
            throw new RuntimeException( "Variable substitution is ambiguous with: {$stKeys}" );
        }

        # There's more to the path after the variable.
        $rMatches = [];
        foreach ( $nodeMatch->rVariableChildren as $stVarName => $tnChild ) {
            $rVariables = [ $stVarName => $stValue ];
            $x = $this->getInner( $tnChild, $stPath, $rVariables, $i_bDecodeVariables );
            if ( null === $x ) {
                continue;
            }
            $rMatches[ $stVarName ] = [ $x, $rVariables ];
        }
        if ( 0 === count( $rMatches ) ) {
            return null;
        }
        if ( 1 === count( $rMatches ) ) {
            $rMatches = array_shift( $rMatches );
            $o_nrVariables = $rMatches[ 1 ];
            return $rMatches[ 0 ];
        }
        $stKeys = join( ', ', array_keys( $rMatches ) );
        throw new RuntimeException( "Variable substitution is ambiguous on '{$stPath}' with: {$stKeys}" );
    }


}
